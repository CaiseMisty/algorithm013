### 283-移动零

此处只记录一次遍历解法的思路. 两者实现上其实差距不大.

思路 1 为严谨的找到 0 与非零两个值后再交换.  
思路 2 稍微抽象一些, 从头到尾遍历, i 逢非 0 就与 head 交换, head 逢交换则后移.

#### 思路 1

遍历数组, 下标为`i`, 新增`zeroIdx`用于保存遍历时遇到 0 的下标.

遍历时, 如果`zeroIdx`不指向 0, 则让`zeroIdx`后移.

当`i`指向非零 且`zeroIdx`指向 0 时, 将`zeroIdx`的值改为`i`的值, `i`位置的值改为 0. (相当于交换两者值)

```js
function moveZeroes(nums) {
  if (nums.length < 2) return nums;
  let zeroIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0 && nums[zeroIdx] === 0) {
      nums[zeroIdx] = nums[i];
      nums[i] = 0;
    }
    if (nums[zeroIdx] !== 0) {
      zeroIdx++;
    }
  }
  return nums;
}
```

#### 思路 2

同上, 遍历数组, 下标为`i`, 新增`head` 用于保存有待于互换的下标, 循环时`i`基本上会走的比`head`更快.

遍历时, `i`不断后移直到遇到非零值, 则`i`与`head`上的值互换, 此时有可能`head`与`i`指向同一位置, 但并不会影响结果. 当位置互换后, `head`后移一位.

```js
function moveZeroes(nums) {
  if (nums.length < 2) return nums;
  let head = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      [nums[head], nums[i]] = [nums[i], nums[head]];
      head++;
    }
  }
  return nums;
}
```

### 11-盛最多水的容器

首先哨兵放在数组左右两侧.
此时如果想在宽度缩小的情况下增大面积, 只能移动短边的哨兵

因为移动哨兵势必导致宽度变小, 如果移动较长边, 长边无论是变长还是变短, 面积都一定会缩小, 所以排除移动长边

移动短边, 面积有可能会增大, 不断的移动, 则会筛选出较优的选择

```js
export default function maxArea(arr) {
  let area = 0;
  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    area = Math.max(getArea(arr, left, right), area);
    if (arr[left] < arr[right]) left++;
    else right--;
  }
  return area;
}

function getArea(arr, left, right) {
  return Math.min(arr[left], arr[right]) * (right - left);
}
```

### 1-两数之和

比较简单, hash 缓存遍历过的值所在下标, 则可以用空间换时间节省一轮遍历.
